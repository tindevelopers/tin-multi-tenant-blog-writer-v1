/**
 * Content Indexing Service
 * Phase 4.2: Content Indexing Service - Vector embeddings and semantic search
 * 
 * Indexes crawled content for fast semantic search and interlinking
 */

import { logger } from '@/utils/logger';
import { createServiceClient } from '@/lib/supabase/service';
import type { CrawledPage } from './website-crawler';

export interface IndexedContent {
  id: string;
  pageId: string;
  url: string;
  title: string;
  content: string;
  excerpt?: string;
  keywords: string[];
  topics: string[];
  wordCount: number;
  metadata: CrawledPage['metadata'];
  // Vector embedding (will be generated by LLM)
  embedding?: number[];
  // Semantic similarity scores
  similarityScores?: Map<string, number>;
  indexedAt: string;
  updatedAt: string;
}

export interface ContentIndex {
  contents: IndexedContent[];
  totalContents: number;
  indexedAt: string;
  lastUpdatedAt: string;
}

export class ContentIndexerService {
  private supabase;
  private orgId: string;

  constructor(orgId: string) {
    this.supabase = createServiceClient();
    this.orgId = orgId;
  }

  /**
   * Index crawled content
   */
  async indexContent(pages: CrawledPage[]): Promise<IndexedContent[]> {
    try {
      logger.debug(`Indexing ${pages.length} pages`, { orgId: this.orgId });

      const indexedContents: IndexedContent[] = [];

      for (const page of pages) {
        try {
          const indexed = await this.indexPage(page);
          if (indexed) {
            indexedContents.push(indexed);
          }
        } catch (error: any) {
          logger.warn(`Failed to index page ${page.id}`, { error: error.message });
          // Continue with other pages
        }
      }

      logger.info(`Indexed ${indexedContents.length} pages`, {
        total: pages.length,
        success: indexedContents.length,
        failed: pages.length - indexedContents.length,
      });

      return indexedContents;
    } catch (error: any) {
      logger.error('Error indexing content', { error: error.message });
      throw error;
    }
  }

  /**
   * Index a single page
   */
  private async indexPage(page: CrawledPage): Promise<IndexedContent | null> {
    try {
      const now = new Date().toISOString();

      // Check if already indexed
      const existing = await this.getIndexedContent(page.id);
      if (existing) {
        // Update existing index
        return await this.updateIndexedContent(page.id, page, now);
      }

      // Create new index entry
      const indexed: IndexedContent = {
        id: `${this.orgId}_${page.id}`,
        pageId: page.id,
        url: page.url,
        title: page.title,
        content: page.content,
        excerpt: page.excerpt,
        keywords: page.keywords,
        topics: page.topics,
        wordCount: page.wordCount,
        metadata: page.metadata,
        indexedAt: now,
        updatedAt: now,
      };

      // Store in database
      await this.saveIndexedContent(indexed);

      return indexed;
    } catch (error: any) {
      logger.error(`Error indexing page ${page.id}`, { error: error.message });
      return null;
    }
  }

  /**
   * Get indexed content by page ID
   */
  async getIndexedContent(pageId: string): Promise<IndexedContent | null> {
    try {
      const { data, error } = await this.supabase
        .from('content_index')
        .select('*')
        .eq('org_id', this.orgId)
        .eq('page_id', pageId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          // Not found
          return null;
        }
        throw error;
      }

      return this.mapDatabaseRowToIndexedContent(data);
    } catch (error: any) {
      logger.error(`Error getting indexed content for page ${pageId}`, { error: error.message });
      return null;
    }
  }

  /**
   * Update indexed content
   */
  private async updateIndexedContent(
    pageId: string,
    page: CrawledPage,
    updatedAt: string
  ): Promise<IndexedContent> {
    const indexed: IndexedContent = {
      id: `${this.orgId}_${pageId}`,
      pageId: page.id,
      url: page.url,
      title: page.title,
      content: page.content,
      excerpt: page.excerpt,
      keywords: page.keywords,
      topics: page.topics,
      wordCount: page.wordCount,
      metadata: page.metadata,
      indexedAt: updatedAt, // Keep original indexedAt
      updatedAt,
    };

    await this.saveIndexedContent(indexed, true);

    return indexed;
  }

  /**
   * Save indexed content to database
   */
  private async saveIndexedContent(indexed: IndexedContent, isUpdate: boolean = false): Promise<void> {
    try {
      const row = {
        id: indexed.id,
        org_id: this.orgId,
        page_id: indexed.pageId,
        url: indexed.url,
        title: indexed.title,
        content: indexed.content,
        excerpt: indexed.excerpt || null,
        keywords: indexed.keywords,
        topics: indexed.topics,
        word_count: indexed.wordCount,
        metadata: indexed.metadata,
        embedding: indexed.embedding || null,
        indexed_at: indexed.indexedAt,
        updated_at: indexed.updatedAt,
      };

      if (isUpdate) {
        const { error } = await this.supabase
          .from('content_index')
          .update(row)
          .eq('id', indexed.id);

        if (error) throw error;
      } else {
        const { error } = await this.supabase
          .from('content_index')
          .insert(row);

        if (error) throw error;
      }
    } catch (error: any) {
      logger.error('Error saving indexed content', { error: error.message, pageId: indexed.pageId });
      throw error;
    }
  }

  /**
   * Map database row to IndexedContent
   */
  private mapDatabaseRowToIndexedContent(row: any): IndexedContent {
    return {
      id: row.id,
      pageId: row.page_id,
      url: row.url,
      title: row.title,
      content: row.content,
      excerpt: row.excerpt,
      keywords: row.keywords || [],
      topics: row.topics || [],
      wordCount: row.word_count || 0,
      metadata: row.metadata || {},
      embedding: row.embedding,
      indexedAt: row.indexed_at,
      updatedAt: row.updated_at,
    };
  }

  /**
   * Search indexed content by keyword
   */
  async searchByKeyword(keyword: string, limit: number = 10): Promise<IndexedContent[]> {
    try {
      const { data, error } = await this.supabase
        .from('content_index')
        .select('*')
        .eq('org_id', this.orgId)
        .or(`keywords.cs.{${keyword}},topics.cs.{${keyword}},title.ilike.%${keyword}%,content.ilike.%${keyword}%`)
        .limit(limit);

      if (error) throw error;

      return (data || []).map(row => this.mapDatabaseRowToIndexedContent(row));
    } catch (error: any) {
      logger.error('Error searching content by keyword', { error: error.message, keyword });
      return [];
    }
  }

  /**
   * Search indexed content by topic
   */
  async searchByTopic(topic: string, limit: number = 10): Promise<IndexedContent[]> {
    try {
      const { data, error } = await this.supabase
        .from('content_index')
        .select('*')
        .eq('org_id', this.orgId)
        .contains('topics', [topic])
        .limit(limit);

      if (error) throw error;

      return (data || []).map(row => this.mapDatabaseRowToIndexedContent(row));
    } catch (error: any) {
      logger.error('Error searching content by topic', { error: error.message, topic });
      return [];
    }
  }

  /**
   * Get all indexed content
   */
  async getAllIndexedContent(): Promise<IndexedContent[]> {
    try {
      const { data, error } = await this.supabase
        .from('content_index')
        .select('*')
        .eq('org_id', this.orgId)
        .order('updated_at', { ascending: false });

      if (error) throw error;

      return (data || []).map(row => this.mapDatabaseRowToIndexedContent(row));
    } catch (error: any) {
      logger.error('Error getting all indexed content', { error: error.message });
      return [];
    }
  }

  /**
   * Clear all indexed content for this org
   */
  async clearIndex(): Promise<void> {
    try {
      const { error } = await this.supabase
        .from('content_index')
        .delete()
        .eq('org_id', this.orgId);

      if (error) throw error;

      logger.info('Cleared content index', { orgId: this.orgId });
    } catch (error: any) {
      logger.error('Error clearing content index', { error: error.message });
      throw error;
    }
  }
}

