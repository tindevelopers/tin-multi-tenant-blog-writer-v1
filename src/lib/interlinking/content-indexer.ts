/**
 * Content Indexing Service
 * Phase 4.2: Content Indexing Service - Vector embeddings and semantic search
 * 
 * Indexes crawled content for fast semantic search and interlinking
 */

import { logger } from '@/utils/logger';
import { createServiceClient } from '@/lib/supabase/service';
import type { CrawledPage } from './website-crawler';

export interface IndexedContent {
  id: string;
  pageId: string;
  url: string;
  title: string;
  content: string;
  excerpt?: string;
  keywords: string[];
  topics: string[];
  wordCount: number;
  metadata: CrawledPage['metadata'];
  // Site tracking for multi-site interlinking
  siteId?: string;
  siteName?: string;
  siteUrl?: string;
  // Vector embedding (will be generated by LLM)
  embedding?: number[];
  // Semantic similarity scores
  similarityScores?: Map<string, number>;
  indexedAt: string;
  updatedAt: string;
}

export interface ContentIndex {
  contents: IndexedContent[];
  totalContents: number;
  indexedAt: string;
  lastUpdatedAt: string;
}

export interface SiteInfo {
  siteId: string;
  siteName?: string;
  siteUrl?: string;
}

export class ContentIndexerService {
  private supabase;
  private orgId: string;
  private siteInfo?: SiteInfo;

  constructor(orgId: string, siteInfo?: SiteInfo) {
    this.supabase = createServiceClient();
    this.orgId = orgId;
    this.siteInfo = siteInfo;
  }

  /**
   * Set site info for indexing (for multi-site support)
   */
  setSiteInfo(siteInfo: SiteInfo) {
    this.siteInfo = siteInfo;
  }

  /**
   * Index crawled content with site awareness
   */
  async indexContent(pages: CrawledPage[], siteInfo?: SiteInfo): Promise<IndexedContent[]> {
    try {
      const effectiveSiteInfo = siteInfo || this.siteInfo;
      logger.debug(`Indexing ${pages.length} pages`, { 
        orgId: this.orgId,
        siteId: effectiveSiteInfo?.siteId,
      });

      const indexedContents: IndexedContent[] = [];

      for (const page of pages) {
        try {
          const indexed = await this.indexPage(page, effectiveSiteInfo);
          if (indexed) {
            indexedContents.push(indexed);
          }
        } catch (error: any) {
          logger.warn(`Failed to index page ${page.id}`, { error: error.message });
          // Continue with other pages
        }
      }

      logger.info(`Indexed ${indexedContents.length} pages`, {
        total: pages.length,
        success: indexedContents.length,
        failed: pages.length - indexedContents.length,
        siteId: effectiveSiteInfo?.siteId,
      });

      return indexedContents;
    } catch (error: any) {
      logger.error('Error indexing content', { error: error.message });
      throw error;
    }
  }

  /**
   * Index a single page with site info
   */
  private async indexPage(page: CrawledPage, siteInfo?: SiteInfo): Promise<IndexedContent | null> {
    try {
      const now = new Date().toISOString();

      // Check if already indexed
      const existing = await this.getIndexedContent(page.id);
      if (existing) {
        // Update existing index
        return await this.updateIndexedContent(page.id, page, now, siteInfo);
      }

      // Create new index entry with site info
      const indexed: IndexedContent = {
        id: `${this.orgId}_${page.id}`,
        pageId: page.id,
        url: page.url,
        title: page.title,
        content: page.content,
        excerpt: page.excerpt,
        keywords: page.keywords,
        topics: page.topics,
        wordCount: page.wordCount,
        metadata: page.metadata,
        siteId: siteInfo?.siteId,
        siteName: siteInfo?.siteName,
        siteUrl: siteInfo?.siteUrl,
        indexedAt: now,
        updatedAt: now,
      };

      // Store in database
      await this.saveIndexedContent(indexed);

      return indexed;
    } catch (error: any) {
      logger.error(`Error indexing page ${page.id}`, { error: error.message });
      return null;
    }
  }

  /**
   * Get indexed content by page ID
   */
  async getIndexedContent(pageId: string): Promise<IndexedContent | null> {
    try {
      const { data, error } = await this.supabase
        .from('content_index')
        .select('*')
        .eq('org_id', this.orgId)
        .eq('page_id', pageId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          // Not found
          return null;
        }
        throw error;
      }

      return this.mapDatabaseRowToIndexedContent(data);
    } catch (error: any) {
      logger.error(`Error getting indexed content for page ${pageId}`, { error: error.message });
      return null;
    }
  }

  /**
   * Update indexed content
   */
  private async updateIndexedContent(
    pageId: string,
    page: CrawledPage,
    updatedAt: string,
    siteInfo?: SiteInfo
  ): Promise<IndexedContent> {
    const indexed: IndexedContent = {
      id: `${this.orgId}_${pageId}`,
      pageId: page.id,
      url: page.url,
      title: page.title,
      content: page.content,
      excerpt: page.excerpt,
      keywords: page.keywords,
      topics: page.topics,
      wordCount: page.wordCount,
      metadata: page.metadata,
      siteId: siteInfo?.siteId,
      siteName: siteInfo?.siteName,
      siteUrl: siteInfo?.siteUrl,
      indexedAt: updatedAt, // Keep original indexedAt
      updatedAt,
    };

    await this.saveIndexedContent(indexed, true);

    return indexed;
  }

  /**
   * Save indexed content to database
   */
  private async saveIndexedContent(indexed: IndexedContent, isUpdate: boolean = false): Promise<void> {
    try {
      const row = {
        id: indexed.id,
        org_id: this.orgId,
        page_id: indexed.pageId,
        url: indexed.url,
        title: indexed.title,
        content: indexed.content,
        excerpt: indexed.excerpt || null,
        keywords: indexed.keywords,
        topics: indexed.topics,
        word_count: indexed.wordCount,
        metadata: indexed.metadata,
        embedding: indexed.embedding || null,
        site_id: indexed.siteId || null,
        site_name: indexed.siteName || null,
        site_url: indexed.siteUrl || null,
        indexed_at: indexed.indexedAt,
        updated_at: indexed.updatedAt,
      };

      if (isUpdate) {
        const { error } = await this.supabase
          .from('content_index')
          .update(row)
          .eq('id', indexed.id);

        if (error) throw error;
      } else {
        const { error } = await this.supabase
          .from('content_index')
          .insert(row);

        if (error) throw error;
      }
    } catch (error: any) {
      logger.error('Error saving indexed content', { error: error.message, pageId: indexed.pageId });
      throw error;
    }
  }

  /**
   * Map database row to IndexedContent
   */
  private mapDatabaseRowToIndexedContent(row: any): IndexedContent {
    return {
      id: row.id,
      pageId: row.page_id,
      url: row.url,
      title: row.title,
      content: row.content,
      excerpt: row.excerpt,
      keywords: row.keywords || [],
      topics: row.topics || [],
      wordCount: row.word_count || 0,
      metadata: row.metadata || {},
      siteId: row.site_id,
      siteName: row.site_name,
      siteUrl: row.site_url,
      embedding: row.embedding,
      indexedAt: row.indexed_at,
      updatedAt: row.updated_at,
    };
  }

  /**
   * Get indexed content by site ID (for multi-site interlinking)
   */
  async getContentBySiteId(siteId: string): Promise<IndexedContent[]> {
    try {
      const { data, error } = await this.supabase
        .from('content_index')
        .select('*')
        .eq('org_id', this.orgId)
        .eq('site_id', siteId)
        .order('updated_at', { ascending: false });

      if (error) throw error;

      logger.debug('Fetched content by site_id', { 
        orgId: this.orgId, 
        siteId, 
        count: data?.length || 0 
      });

      return (data || []).map(row => this.mapDatabaseRowToIndexedContent(row));
    } catch (error: any) {
      logger.error('Error getting content by site_id', { error: error.message, siteId });
      return [];
    }
  }

  /**
   * Search indexed content by keyword (optionally filtered by site)
   */
  async searchByKeyword(keyword: string, limit: number = 10, siteId?: string): Promise<IndexedContent[]> {
    try {
      let query = this.supabase
        .from('content_index')
        .select('*')
        .eq('org_id', this.orgId)
        .or(`keywords.cs.{${keyword}},topics.cs.{${keyword}},title.ilike.%${keyword}%,content.ilike.%${keyword}%`)
        .limit(limit);

      if (siteId) {
        query = query.eq('site_id', siteId);
      }

      const { data, error } = await query;

      if (error) throw error;

      return (data || []).map(row => this.mapDatabaseRowToIndexedContent(row));
    } catch (error: any) {
      logger.error('Error searching content by keyword', { error: error.message, keyword });
      return [];
    }
  }

  /**
   * Search indexed content by topic (optionally filtered by site)
   */
  async searchByTopic(topic: string, limit: number = 10, siteId?: string): Promise<IndexedContent[]> {
    try {
      let query = this.supabase
        .from('content_index')
        .select('*')
        .eq('org_id', this.orgId)
        .contains('topics', [topic])
        .limit(limit);

      if (siteId) {
        query = query.eq('site_id', siteId);
      }

      const { data, error } = await query;

      if (error) throw error;

      return (data || []).map(row => this.mapDatabaseRowToIndexedContent(row));
    } catch (error: any) {
      logger.error('Error searching content by topic', { error: error.message, topic });
      return [];
    }
  }

  /**
   * Get all indexed content (optionally filtered by site)
   */
  async getAllIndexedContent(siteId?: string): Promise<IndexedContent[]> {
    try {
      let query = this.supabase
        .from('content_index')
        .select('*')
        .eq('org_id', this.orgId)
        .order('updated_at', { ascending: false });

      if (siteId) {
        query = query.eq('site_id', siteId);
      }

      const { data, error } = await query;

      if (error) throw error;

      return (data || []).map(row => this.mapDatabaseRowToIndexedContent(row));
    } catch (error: any) {
      logger.error('Error getting all indexed content', { error: error.message });
      return [];
    }
  }

  /**
   * Clear indexed content (optionally for a specific site only)
   */
  async clearIndex(siteId?: string): Promise<void> {
    try {
      let query = this.supabase
        .from('content_index')
        .delete()
        .eq('org_id', this.orgId);

      if (siteId) {
        query = query.eq('site_id', siteId);
      }

      const { error } = await query;

      if (error) throw error;

      logger.info('Cleared content index', { orgId: this.orgId, siteId });
    } catch (error: any) {
      logger.error('Error clearing content index', { error: error.message });
      throw error;
    }
  }

  /**
   * Get list of all sites that have indexed content
   */
  async getIndexedSites(): Promise<Array<{ siteId: string; siteName: string | null; count: number }>> {
    try {
      const { data, error } = await this.supabase
        .from('content_index')
        .select('site_id, site_name')
        .eq('org_id', this.orgId)
        .not('site_id', 'is', null);

      if (error) throw error;

      // Group by site_id and count
      const siteMap = new Map<string, { siteName: string | null; count: number }>();
      for (const row of data || []) {
        const existing = siteMap.get(row.site_id);
        if (existing) {
          existing.count++;
        } else {
          siteMap.set(row.site_id, { siteName: row.site_name, count: 1 });
        }
      }

      return Array.from(siteMap.entries()).map(([siteId, info]) => ({
        siteId,
        siteName: info.siteName,
        count: info.count,
      }));
    } catch (error: any) {
      logger.error('Error getting indexed sites', { error: error.message });
      return [];
    }
  }
}

